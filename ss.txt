// نمایشگرها و متغیرهای اصلی
const mainDisplay = document.getElementById("display");
const historyDisplay = document.getElementById("historyContent");

let isFinalResultCalculated = false;
let lastInput = '';
let expression = "";
let memory = null;

// کلاس Stack برای مدیریت عملیات
class Stack {
    constructor() {
        this.items = [];
    }
    push(element) { this.items.push(element); }
    pop() { return this.isEmpty() ? null : this.items.pop(); }
    peek() { return this.isEmpty() ? null : this.items[this.items.length - 1]; }
    isEmpty() { return this.items.length === 0; }
}

// توابع مربوط به ورودی کاربر
function appendNumber(input) {
    if (isFinalResultCalculated) {
        _resetForNewInput(input);
    } else {
        _handleNumberInput(input);
    }
    lastInput = 'number';
}

function appendOperator(input) {
    if (input === 'pm') return toggleSign();
    if (input === 'sqrt') return appendSpecialOperator('sqrt');
    _handleOperatorInput(input);
    _autoCalculate();
}

function calculate(isFromOperator = false) {
    try {
        const result = _compute();
        mainDisplay.value = result;
        memory = result;

        if (!isFromOperator) _updateHistoryWithResult(result);
    } catch (error) {
        _handleError(error);
    } finally {
        _finalizeCalculation(isFromOperator);
    }
}

function clearDisplay() {
    mainDisplay.value = '0';
    historyDisplay.innerText = '';
    expression = "";
    lastInput = 'number';
    memory = null;
}

function backspace() {
    if (expression.length > 0) {
        _handleBackspace();
    }
}

// مدیریت ورودی صفحه‌کلید
document.addEventListener('keydown', function (event) {
    event.preventDefault();
    if (!isNaN(event.key)) appendNumber(event.key);
    else if (['+', '-', '*', '/'].includes(event.key)) appendOperator(event.key);
    else if (event.key === 'Enter') calculate();
    else if (event.key === '.') appendNumber(event.key);
    else if (event.key === 'Backspace') backspace();
});

// توابع کمکی داخلی
function _resetForNewInput(input) {
    isFinalResultCalculated = false;
    mainDisplay.value = input;
    expression = input;
    historyDisplay.innerText = input;
}

function _handleNumberInput(input) {
    if (lastInput === 'operator') {
        mainDisplay.value = input;
        expression += input;
    } else if (input === '.' && mainDisplay.value.includes('.')) {
        return; // جلوگیری از ورود چند نقطه
    } else if (_isErrorState(mainDisplay.value)) {
        mainDisplay.value = input;
        expression = input;
    } else if (mainDisplay.value.replace('.', '').length < 11) {
        mainDisplay.value += input;
        expression += input;
    }
    historyDisplay.innerText = expression;
}

function _handleOperatorInput(input) {
    const operators = ['+', '-', '*', '/'];

    if (operators.includes(input)) {
        if (isFinalResultCalculated) _resetAfterFinalResult(input);
        else if (lastInput === 'number') _appendOperatorToExpression(input);
        else if (lastInput === 'operator') _replaceLastOperator(input);
    }
    lastInput = 'operator';
}

function _autoCalculate() {
    const matches = expression.match(/[+\-*/]/g);
    if (matches && matches.length >= 2) calculate(true);
}

function _updateHistoryWithResult(result) {
    const lastChar = historyDisplay.innerText.trim().slice(-1);
    const operators = ['+', '-', '*', '/'];

    if (operators.includes(lastChar)) {
        historyDisplay.innerText = historyDisplay.innerText.slice(0, -1);
    }
    historyDisplay.innerText += ` = ${result}`;
}

function _handleBackspace() {
    const lastChar = expression.slice(-1);

    if (!isNaN(lastChar) || lastChar === '.') {
        expression = expression.slice(0, -1);
        mainDisplay.value = mainDisplay.value.slice(0, -1);
        historyDisplay.innerText = historyDisplay.innerText.slice(0, -1);
        if (!mainDisplay.value) mainDisplay.value = '0';
    }
}

function toggleSign() {
    if (lastInput === 'number' && mainDisplay.value) {
        let currentValue = parseFloat(mainDisplay.value) * -1;
        mainDisplay.value = currentValue;
        expression = currentValue.toString();
        historyDisplay.innerText = expression;
    }
}

function appendSpecialOperator(operator) {
    if (lastInput === 'number') {
        expression += operator;
        historyDisplay.innerText += ` ${operator} `;
    }
}

// مدیریت محاسبات
function _compute() {
    const _numbers = new Stack();
    const _operators = new Stack();
    const precedence = { '+': 1, '-': 1, '*': 2, '/': 2, '^2': 3, 'sqrt': 3, 'cos': 3 };

    const tokens = expression.match(/\d+(\.\d+)?|sqrt|cos|\^2|[+\-*/()]/g);
    tokens.forEach(token => {
        if (!isNaN(token)) _numbers.push(parseFloat(token));
        else _handleToken(token, _numbers, _operators, precedence);
    });

    while (!_operators.isEmpty()) _processStacks(_numbers, _operators);
    return parseFloat(_numbers.peek().toFixed(4));
}

function _handleToken(token, numbers, operators, precedence) {
    while (!operators.isEmpty() && precedence[operators.peek()] >= precedence[token]) {
        const op = operators.pop();
        const right = numbers.pop();
        const left = numbers.pop();
        numbers.push(_applyOperator(left, right, op));
    }
    operators.push(token);
}

function _processStacks(numbers, operators) {
    const op = operators.pop();
    const right = numbers.pop();
    const left = numbers.pop() || 0;
    numbers.push(_applyOperator(left, right, op));
}

function _applyOperator(left, right, operator) {
    const operations = {
        '+': (a, b) => a + b,
        '-': (a, b) => a - b,
        '*': (a, b) => a * b,
        '/': (a, b) => b === 0 ? Infinity : a / b,
        '^2': (_, b) => b ** 2,
        'sqrt': (_, b) => Math.sqrt(b),
        'cos': (_, b) => Math.cos(b * Math.PI / 180)
    };
    return operations[operator](left, right);
}

function _finalizeCalculation(isFromOperator) {
    isFinalResultCalculated = !isFromOperator;
    lastInput = isFromOperator ? 'operator' : 'number';
}

function _isErrorState(value) {
    return ['0', 'Error!', 'Infinity'].includes(value);
}

function _handleError(error) {
    mainDisplay.value = error.message === "Division by zero" ? "Infinity!" : "Error";
    console.error(error.message);
}

function _resetAfterFinalResult(operator) {
    expression = memory.toString() + operator;
    historyDisplay.innerText = `${memory} ${operator}`;
    isFinalResultCalculated = false;
}

function _appendOperatorToExpression(operator) {
    expression += operator;
    historyDisplay.innerText += ` ${operator} `;
}

function _replaceLastOperator(operator) {
    expression = expression.slice(0, -1) + operator;
    historyDisplay.innerText = historyDisplay.innerText.slice(0, -2) + ` ${operator} `;
}

*************************************************
    lastInput = isFromOperator ? 'operator' : 'number';

در آخرین خط کلکوکیشن
*************************************************

function calculate(isFromOperatore) {
    try {
        const result = _compute(isFromOperatore);
        mainDisplay.value = result;
        memory = result;
        if (!isFromOperatore) {
            const lastChar = historyDisplay.innerText.trim().slice(-1);
            const operators = ['+', '-', '*', '/'];
            if (operators.includes(lastChar)) {
                historyDisplay.innerText = historyDisplay.innerText.trim().slice(0, -1); // حذف آخرین اپراتور
            }
            historyDisplay.innerText +=  = ${result}; // برای محاسبه نهایی
        }
    } catch (error) {
        if (error.message === "Division by zero") {
            mainDisplay.value = "Infinity!";
        } else {
            mainDisplay.value = "Error";
            console.error(error.message)
        }
    } finally {
        isFinalResultCalculated = !isFromOperatore;
        if (isFromOperatore) {
            lastInput = 'operator';
        } else {
            lastInput = 'number';
        }
    }
}